% !TEX root = ../Main.tex

\chapter[Simulating Quantum Circuits with Stabilizer Rank]{Simulating Quantum Circuits with the\\ Stabilizer Rank Method}\label{chap:simulator}
% Look at combining the previous two chapters
% Build stabilizer decompositions, then simulate circuits efficiently for each term
% Here, present methods for operating on the decompositions, for practical simulation
\section{Introduction}
% Focus on not asymptotic overhead, but implrementations of simulators
Previously, we have discussed decompositions of quantum computations, where each individual term can be efficiently simulated classically. This connection to classical simulation gives an easy operational interpretation to these decompositions, and suggests a way of building a classical simulator along these lines. In this chapter, we will make this connection explicit, introducing methods that can be used to simulate universal quantum circuits, and discussing their implementations.\par
% Use for benchmarking, verification, and prototyping and development
As discussed, efficient classical simulation of quantum effects is broadly believed to be intractable. Nonetheless, classical simulations play an important role in the research and development of quantum technologies. In recent years, fas quantum hardware has continued to improve, an increasingly important role of simulations has been to support the transition and adoption of quantum technology. Providing classical simulators as a test bed enables the development of software engineering, protocols and applications that take into account non-classical features, even while access to actual quantum devices is still limited. \par
For example, \texttt{SimulaQron} and \texttt{NetSquid} are classical simulations of quantum communications networks, developed as part of an effort to promote the development of practical quantum communications~\cite{Dahlberg2017,NetSquid}. These tools have been used to develop proposals for link layer protocols in quantum networks, which can then be tested in the lab~\cite{Dahlberg2019}.\par
In the context of quantum computing, many classical simulators in use today form part of `Quantum Development Kits' (QDKs), software environments for the development of quantum software. These tools broadly follow a similar architecture to that of \texttt{ProjectQ}, described in~\cite{Haner2018}. Typically, the user-facing component is a `high-level' description of a quantum programme, either as an API or with a domain-specific language (DSL), which is agnostic to how it will be evaluated. These programmes can be built out of algorithms and meta-algorithms, such as the Variational Quantum Eigensolver; subroutines and operations, such as the quantum Fourier transform; or even individual gates. The resulting description of the programme can then be compiled to a quantum circuit, and either simulated clasically, or else dependent on requirements further compiled and dispatched to a quantum processor. Multiple such QDKs have been developed over the past 5 years, and a brief summary of the some of the available options is shown in Table~\ref{tab:qdks}.
\begin{table}[H]
\begin{tabular}{|l|c|c|c|}
\toprule
Framework & \makecell{High-level\\Description} & \makecell{Classical\\ Methods} & \makecell{Supported\\ Hardware} \\ \midrule
Microsoft QDK~\cite{MicrosoftQDK} & \texttt{Q\#}~\cite{Svore2018} & State vector & None \\\midrule
\texttt{ProjectQ}~\cite{Steiger2016} & DSL & State vector & IBMQ~\cite{IBMQ} \\\midrule
\texttt{Qiskit}~\cite{Qiskit} & \makecell{QASM~\cite{Cross2017},\\ \texttt{Python} API} & Various & IBMQ~\cite{IBMQ}\\\midrule
\texttt{Circ}~\cite{GoogleCirc} & \texttt{Python} API & \makecell{State vector,\\density matrix} & Bristlecone\footnote{These chips are not currently publicly accessible.}~\cite{CircAnnouncement}\\\midrule
\texttt{Forest}~\cite{RigettiForest} & \makecell{Quil,\\ Python API~\cite{Smith2016}} & \makecell{State vector \\ density matrix} & Rigetti QPU~\cite{RigettiQPU}\\ \bottomrule
\end{tabular}
\caption{A non-exhaustive list of different quantum software frameworks or QDKs. We note that many of these frameworks have additional components aimed at supporting application development that are not mentioned here.}\label{tab:qdks}
\end{table}
% Qiskit, Circ etc use statvector methods
In practice, most of the QDKs mentioned above make use of what could be described as `textbook' classical simulations of quantum computing, where a circuit is simulated by matrix multiplication of the unitary associated with each gate, acting on either a state-vector or a density matrix description~\cite{Nielsen2000}.\par
These simulators have the advantage that they are relatively straightforward to implement, and can leverage mature computational libraries for matrix maths such as \texttt{Numpy}~\cite{Numpy}. Probabilities in the computational basis can also be trivially obtained, either by reading off the right diagonal entry in the density matrix or computing the absolute value squared of the corresponding amplitude in a state-vector. Noise in these models is also relatively straightforward to model, either by using a stochastic noise model inserting extra operators into the circuit in the state-vector case, or else applying Kraus operators directly in the density matrix case~\cite{Nielsen2000}.\par
However, the main drawback to these simulators is their spatial complexity. A state-vector requires $2^{n}$ complex numbers to define, and a density matrix requires up to $2^{2n}$, where $n$ is the number of qubits. As each complex number requires two $64$-bit floating point numbers to specify, the memory requirements can quickly approach the limits of personal computing. A simulation on $30$ qubits requires $16$GB of memory, and up to $45$ qubits this requires $0.5$PB~\cite{Haner2016}. The current top-ranked supercomputer in the world has access to $2.7$PB of memory, meaning it could simulate up to $47$ qubits using these methods~\cite{Top500}.\par
These classical representations also have a significant temporal overhead. In the most straightforward implementation, applying gates requires multiplying $2^{n}\times 2^{n}$ matrices. These updates require time $2^{2n}$ in the state-vector case, and $2^{4.746n}$ for density matrices. In practice though, significant optimizations are possible that can make state-vector simulators reasonably performant at accessible sizes. For example, the $2^{n}\times 2^{n}$ matrices representing single qubit gates are sparse, with the vast  majority of entries being $0$. Other optimizations that have been applied include parallelising single-qubit gate updates~\cite{Smelyanskiy2016,Khammassi2017,Smelyanskiy2016,QiskitAer}, optimising permutation operations such as CNOT and Pauli $X$~\cite{Khammassi2017}, replacing certain arithmetic operations with classical equivalents~\cite{Haner2016}, and accelerating algorithms using parallel execution via \texttt{OpenMP}, \texttt{MPI} or GPUs~\cite{Jones2018,Smelyanskiy2016,Khammassi2017,QiskitAer}.\par
% Mention the other role, of verification and benchmarking
In practice, this limit of approximately $30$ qubits when simulating circuits with personal computers roughly corresponds to the kind of quantum programmes that can be run on current publicly accessible devices, which have anywhere from $5$-$20$ qubits~\cite{IBMQ,RigettiQPU}. However, with continued development of quantum hardware into the 50--72 qubit range~\cite{IBM50,GoogleBristlecone}, classical simulations need to be pushed further, to continue in their other role in the verification and benchmarking of quantum devices.\par
Given the expected intractability of classical simulations at large enough system sizes, the question of verifying quantum computations without simulation constitutes a separate branch of research based on the idea of `interactive proofs'~\cite{Aharonov2017,Mahadev2018}. Nonetheless, classical simulations offer a unique opportunity in verification as at any point the simulation can be paused and the system state inspected. Large-scale classical simulations also provide a performance baseline, as part of attempts to establish Quantum Supremacy.\par
% Other simulators usually special purpose, optimised to do better to fit this role
Recent work has focused on tensor-network methods in particular to push classical simulations up past $45$ qubits, and have achieved some of the largest scale classical simulations to date~\cite{Pendault2017,Chen2018,Chen2018b,Markov2018,Villalonga2019}. Tensor networks are undirected graphs, where tensors represent input and output states, and quantum gates, and edges represent qubit wires~\cite{Boixo2017}. Tensors are combined or contracted by summing over shared indices, with a runtime that scales as the product of the dimensions of the indices to be contracted. For fixed input and output states $x$ and $y$, contracting the entire network results in a rank-0 tensor or scalar value which corresponds to the amplitude $\matrixel{x}{u}{y}$~\cite{Markov2005}.\par
These papers on large classical simulations focus on on simulating quantum circuits on grids of qubits with local connectivity. This restriction is motivated by the designs of current quantum processors, and also allows for specific optimizations that reduce the temporal complexity of the simulation. State of the art methods typically split this grid into sub-blocks, which are locally contracted leaving only connections between blocks~\cite{Pendault2017,Chen2018b,Markov2018,Villalonga2018}. The remaining $s$ contractions are then `sliced', fixed to one of $2^{s}$ values and then contracted fully~\cite{Pendault2017}. This has a natural operational interpretation in terms of a sum-over-paths expansion~\cite{Markov2018}, and has the advantage that the contractions within blocks can be parallelised.\par
These methods all achieve runtimes that scale as $\max \left[ 2^{dl}, 2^{n}\right]$, where $l$ is the length of the longest edge of the grid~\cite{Markov2005}. They also have exponential spatial requirements, though these are reduced compared to a state-vector method by virtue of tensor slicing. Through application of supercomputing resources, these methods have simulated random universal circuits of up to depth $40$ on $72$ qubits~\cite{Villalonga2018}, depth $35$ on $100$ qubits~\cite{Chen2018}, and depth $24$ on $121$ qubits~\cite{Villalonga2019}.\par
Because this generated of quantum hardware aims to  maximize qubit count, it will not employ full error-correction routines. As a result, noise is a significant factor in the system, and limits the depth of circuits that can be run. We refer to this regime of quantum computing as `Noisy Intermediate Scale Quantum' or NISQ~\cite{Preskill2018}. Thus, much like system size for the state-vector simulator, the exponential simulation overhead in the depth does not render the simulations intractable. In fact, simulators can benefit from the increased noise level, by dropping terms from the simulation and reducing the overall computational time required by a constant factor, as discussed in Section~\ref{sec:srank_discussion}.
\section{Results}
In the rest of this chapter, we will discuss a distinct method for simulating universal quantum circuits, based on stabilizer state decompositions. We will present simulation results for several types of quantum circuit, and argue that this method has a great potential for simulating circuits on current and near-term quantum hardware.\par
\subsection{Methods for Manipulating Stabilizer Decompositions}
At a high level, simulating a quantum circuit $U$ using a decomposition into efficiently simulable terms requires two main stems. Firstly, we need to build a representation of the circuit state $U\ket{x}$ for an input state $\ket{x}$, which is itself part of our efficiently representable set of states. Then, we need a routine for computing output variables from the distribution, either computing explicit probabilities if we interested in strong simulation, or else sampling from the output distribution if we are interested in weak simulation.\par
In the following, we will use $\mathtt{U}$ to denote a classical description of the quantum circuit $U$. We store $\mathtt{U}$ as a sequence of gates, where each gate includes its label, e.g.\ `H', and the labels of the qubits it acts on.\par
Stabilizer states will be encoded classically using either the CH or the DCH representations, introduced in Chapter~\ref{chap:stabilizers}.
\subsubsection*{Building Decompositions}
The main method for constructing a stabilizer state decomposition, given a description of a quantum circuit $U$, is the PBC method introduced in~\cite{Bravyi2015} and~\cite{Bravyi2016}, and outlined previously in Sections~\ref{sec:pbc} and~\ref{sec:pbc_decomposition}. We will review the method briefly here, with a focus on implementation in software. \par
Implementing a PBC requires rewriting $U$ as an equivalent Clifford circuit $V$. We achieve this by walking through the circuit $\texttt{U}$, and replacing each of the $m$ non-Clifford gate with an appropriate magic state or states, and state-injection gadget, such as the example shown in Figure~\ref{fig:t_inject}. We note that this requires a library of known gadgets for implementing different gates. The result is a new circuit $U'$, acting on $n$ qubits and $m$ magic states.\par
State-injection gadgets include additional, measurement controlled `correction' operations. By post-selecting on these measurement-outcomes, we can expand out $U'$ as a sum of different Clifford circuits $V_{y}$
\[U\ket{x} = \sum_{y}\matrixel{y}{V_{y}}{x\otimes \psi} \]
where $y$ is the post-selection string with length $O(m)$, and $\ket{\psi}$ is the joint state of all the magic states.\par
It was shown in~\cite{Bravyi2016} that given some approximate stabilizer state decomposition of the magic states $\ket{\tilde{\psi}}$, we can construct a PBC to sample from the output distribution of the circuit by sampling the post-selection string at random. Thus, for each gadget, we sample the measurement outcomes appropriately to build-up the Clifford circuit $\mathtt{V}$.\par
As previously discussed, when injecting a gate $U$ the correction operation has the form $UPU^{\dagger}$ for some Pauli operator $P$. If $U\in\mathcal{C}_{3}$, then by definition $UPU^{\dagger}$ is a Clifford operator and we are done. Otherwise, we will need to introduce additional layers of state-injection until we build an all-Clifford circuit $\mathtt{V}$.\par
Finally, we need to construct an approximate stabilizer state decomposition for the magic states $\ket{\psi}$. In general, $\ket{\psi}$ will be a tensor-product of different `species' of magic state, and so we build the full approximation using the multiplicative upper bound
\[\chi_{\epsilon}\left(\ket{\psi}\right) = \chi_{\epsilon}\left(\ket{T}^{\# T}\right)\,\chi_{\epsilon}\left(\ket{CCX}^{\# CCX}\right)\,\chi_{\epsilon}\left(\ket{\theta}^{\#\theta}\right)\cdots\]
For Clifford magic states, we can make use of the random codes construction. Otherwise, we can use sparsification. We note that this again implies a library of best-known decomposition strategies for each magic-state we introduce.\par
Overall then, the gadgetization method takes as input a classical description of an $n$-qubit circuit $\mathtt{U}$ and target error $\epsilon$, and returns a new description of a Clifford circuit $\mathtt{V}$ acting on $n$ qubits and $m$ magic states, the corresponding post-selection string $\va{y}$, and an approximate stabilizer state decomposition $\mathtt{\ket{\tilde{\psi}}}$. A pseudo-code description of this method is given in Algorithm~\ref{alg:gadgetize_decomposition}.\par
\large{\itshape{The Sum-over-Cliffords picture}}\par
The PBC model has an interesting feature where the number of qubits in the stabilizer state expansion depends only on the magic states, and not on the number of qubits in the circuit. Stabilizer circuits are efficient to simulate in terms of the number of qubits, but the $O(n^{3})$ overhead is still considered significant in practice. Thus, if there are fewer magic states, the PBC can reduce the number of variables in the simulation. But, in general, universal quantum computations have a number of gates that scales as $\poly\left(n\right)$, and gadgetization will result in more qubits.\par
An alternative strategy for building stabilizer state decompositions makes use of the equivalence between stabilizer circuits and stabilizer states. If we consider a Clifford gate decomposition $Q=\sum_{i}\alpha_{i}V_{i}$, then the action of $Q$ on a stabilizer state results in a stabilizer state decomposition
\begin{equation}
Q\ket{\phi} = \sum_{i}\alpha_{i}V_{i}\ket{\phi} = \sum_{i}\alpha_{i}\ket{\phi_{i}},
\end{equation}
which we can then turn into an approximation stabilizer state decomposition with sparsification, giving a decomposition with a rank $O(\norm{\va{\alpha}}^{2})$.\par
From this, we can define a notion of `extent' for a unitary
\begin{equation}
\xi\left(Q\right) = \min_{V}\norm{\va{\alpha}}^{2} \;:\;Q=\sum_{i}\alpha_{i}V_{i}.
\end{equation}
For example, considering single-qubit rotations in around the $Z$ axis of a Bloch sphere with $\theta\in[0,\pi/2$, we can expand them into two Clifford branches
\begin{equation}
R_{Z}\left(\theta\right) = \left(\cos{\frac{\theta}{2}}-\sin{\frac{\theta}{2}}\right)I + \mathe^{-\mathi\pi/4}\sqrt{2}\sin{\frac{\theta}{2}}S,
\label{eq:rotation_expansion}
\end{equation}
with corresponding extent $\xi\left(R\left(\theta\right)\right)=\left(\cos{\frac{\theta}{2}}+\tan{\frac{\pi}{8}}\sin{\frac{\theta}{2}}\right)^{2}$~\cite{Bravyi2018}. Similar results can be found for all $Z$ rotations, where we slightly adjust the phase and the Clifford operations on each branch.\par
This expansion corresponds with the stabilizer extent of the $\ket{T}$ state by setting $\theta=\frac{\pi}{4}$. In fact, it was shown by Earl Campbell that for injectable Clifford magic states, such as $\ket{T}$ and $\ket{CCZ}$, that the extent-optimal stabilizer state decomposition can be used to `lift' a Clifford gate expansion of the corresponding unitary (i.e.\ $T$ and $CCZ$), that is also optimal~\cite{Bravyi2018}.\par
Using submultiplicativty, we can thus upper-bound the stabilizer extent of the circuit $U$ as
\begin{equation}
\xi\left(U\right) = \prod_{i=1}^{m}\xi\left(U_{i}\right)
\end{equation}
for each non-Clifford gate $U_{i}$. We can then build up a term in the stabilizer state decomposition by iterating through $\mathtt{U}$. If the gate is Pauli or Clifford, we just apply it and update the state. Otherwise, for each non-Clifford gate $U_{i}$ we sample a branch from the Clifford expansion with $p_{i,j}=\frac{\left|\alpha_{i,j}\right|}{\norm{\va{\alpha_{i}}}}$ as in the sparsification method, and apply the corresponding Clifford gate $V_{i,j}$. We can repeat this $O(\xi\left(U\right))$ times, to produce a stabilizer state decomposition of the $U\ket{x}$. This algorithm is outined in Algorithm~\ref{alg:soc_decomposition}.\par
\begin{algorithm}[p]
\begin{algorithmic}
\Require{Known set of gadgets for non-Clifford gates.}
\Function{GadgetDecomposition}{$\mathtt{U}, \epsilon$}
    \State{ $\mathtt{V}\gets \emptyset$ \Comment{Output Clifford circuit}}
    \State{ $\ket{\psi}\gets \emptyset$ \Comment{Magic states}}
    \For{$\mathtt{U_{i}}\in \mathtt{U}$}
        \If{$U_{i} \notin \mathcal{C}_{2}$}
            \State{ Sample a measurement outcome $z$}
            \State{ $\mathtt{V}\gets \mathtt{V}\cap\mathtt{G}\cap\mathtt{V}_{z}$} \Comment{$\mathtt{G}$ is the gadget for $U_{i}$.}
            \State{ $\ket{\psi}\gets\ket{\psi}\otimes \psi_{G}$ \Comment{Magic state associated with $\mathtt{G}$}}
        \Else
            \State{ $\mathtt{V} \gets \mathtt{V}\cap \mathtt{U_{i}}$}
        \EndIf
    \EndFor
    \State{ Reorder qubits in $\mathtt{V},\ket{\psi}$ to join common species of magic state}
    \State{ $\ket{\tilde{\psi}}=\emptyset$}
    \For{$\ket{\psi_{U_{j}}^{\otimes \# U_{j}}}\in\ket{\psi}$}
        \State{ $\ket{\tilde{\psi}}\gets \ket{\tilde{\psi}}\otimes \ket{\tilde{\psi_{U_{j}}}}$ \Comment{Rank is set by $\epsilon$.}}
    \EndFor
    \State{ \Return{$\mathtt{V}$, $\ket{\tilde{\psi}}$}}
\EndFunction
\end{algorithmic}
\caption{Pseudocode description of the computational routine for construction a stabilizer state decomposition of a quantum circuit using state-injection gadgets.}\label{alg:gadgetize_decomposition}
\end{algorithm}
\begin{algorithm}[p]
\begin{algorithmic}
\Require{Clifford decompositions of non-Clifford gates.}
\Function{SumOverCliffordDecomposition}{$\mathtt{U}, \epsilon, \ket{x}$}
    \State{$\ket{\tilde{\psi}} = \emptyset$}
    \State{$\xi\gets$ \Call{ComputeExtent}{$\mathtt{U}$}}
    \State{$i\gets 0$}
    \While{$i<\chi_{\epsilon}= O\left(\xi \epsilon^{-2}\right)$}
        \State{$\ket{\phi} \gets\ket{x}$}
        \State{$c\gets 1$}
        \For{$U_{i}\in\mathtt{U}$}
            \If{$U_{i}\notin \mathcal{C}_{2}$}
                \State{Sample Clifford branch $j$ of gate $U_{i}$}
                \State{$\ket{\phi}\gets V_{i,j}\ket{\phi}$}
                \State{$c\gets \frac{\alpha_{i,j}}{\left|\alpha_{i,j}\right|}\, c$}
            \Else
                \State{$\ket{\phi}\gets U_{i}\ket{\phi}$}
            \EndIf
        \EndFor
        \State{$\ket{\tilde{\psi}}\gets \ket{\tilde{\psi}}+c\ket{\phi}$}
        \State{$i\gets i+1$}
    \EndWhile
    \State{\Return $\ket{\tilde{\psi}}$}
\EndFunction
\end{algorithmic}
\caption{Pseudocode description of building stabilizer state decompositions in the sum-over-Cliffords picture.}\label{alg:soc_decomposition}
\end{algorithm}
\begin{algorithm}[p]
\begin{algorithmic}
\Require{$L$, number of samples to take, $n$, number of qubits, $\Pi$, Pauli projector}
\Function{NormEstimation}{$\Pi$, $\ket{\tilde{\psi}}$}
    \State{$\va{\eta} \gets \{\eta_{i}=0\}$}
    \State{$\{\ket{\eta_{i}}\}\gets $\Call{RandomEquatorialState}{n}}
    \For{$\alpha_{i},\;\ket{\phi_{i}}\in\ket{\tilde{\phi}}$}
        \State{$\Gamma\gets 1$}
        \For{$P\in\Pi$}
            \State{$\Gamma_{P},\ket{\phi_{i}} \gets$\Call{MeasurePauli}{$P$,$\ket{\phi}}$}
            \If{$\Gamma_{P}=0$}
                \State{$\Gamma\gets 0$, Break loop}
            \EndIf
            \State{$\Gamma\gets\Gamma\,\Gamma_{P}$}
        \EndFor
        \If{$\Gamma \neq 0$}
            \For{$\ket{\eta_{i}}\in \{\ket{\eta_{i}}\}$}
                \State{$\eta_{i}\gets \Gamma\,\alpha_{i}\,\braket{\eta_{i}}{\phi_{i}}$}
            \EndFor
        \EndIf
    \EndFor
    \State{\Return{$\frac{2^{n}}{L}\sum_{i}\left|\eta_{i}\right|^{2}$}}
\EndFunction
\end{algorithmic}
\caption{Pseudocode outline of the Norm Estimation routine for computing expectation values of Pauli projectors.}\label{alg:norm_estimation}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}
\Require{$n$, number of qubits}
\Function{MetropolisSampling}{$\ket{\tilde{\psi}}$, $m$}
\State{$\va{x}\gets $ Random initial $n$-bit binary string}
\State{$p_{x}\gets \left|\sum_{i}\alpha_{i}\braket{x}{\phi_{i}}\right|^{2}$}
\For{$j\in [1,\dots,n]$}
    \State{$j\gets$ Random integer $\in [1,\dots,n]$}
    \State{$\va{x}' \gets \va{x}\oplus \va{e}_{j}$}
    \State{$p_{x'}\gets \left|\sum_{i}\alpha_{i}\braket{x'}{\phi_{i}}\right|^{2}$}
    \If {$p_{x}=0\vee p_{x'}=0$}
        \State{$x\gets x'$, $p_{x}\gets p_{x'}$}
    \Else
        \State{Generate $r\in[0,1)$ uniformly at random}
        \If{$r<\frac{p_{x}}{p_{x'}}$}
            \State{$x\gets x'$, $p_{x}\gets p_{x'}$}
        \EndIf
    \EndIf
\EndFor
\State{\Return{$\va{x}$}}
\EndFunction
\end{algorithmic}
\caption{Pseudocode description of the Metropolis-style Monte Carlo method for sampling a computational basis string $x$ from the output distribution of a stabilizer state decomposition.}\label{alg:metropolis}
\end{algorithm}
\subsubsection*{Output Variables}
There are two main methods for computing output variables from a given stabilizer state decomposition. The first is the `norm estimation' routine, introduced in~\cite{Bravyi2016} and refined in~\cite{Bravyi2018}. Norm estimation can be used to compute measurement probabilities, and also to sample as described in Section~\ref{sec:pbc_decomposition}. The second is a Metropolis-style Monte Carlo method, which can be used to return samples in the computational basis. Both methods were developed by Sergey Bravyi, and we introduce them here with a view to their implementation. The two methods are also outlined in Algorithms~\ref{alg:norm_estimation} and~\ref{alg:metropolis}, respectively.\par
\large{\itshape{Norm Estimation}}\par
This routine allows us to quickly compute an approximation to $\norm{\psi}$. Importantly, given a projector $\Pi$, we can compute the probability of that outcome as
\begin{equation}
p\left(\Pi\right) = \frac{\norm{\Pi \psi}^{2}}{\norm{\psi}^{2}}.
\end{equation}
In particular, it is possible to show that if we generate equatorial stabilizer states $\ket{\eta}$ uniformly at random, then the random variable $\eta\equiv 2^{n/2}\left|\braket{\eta}{\psi}\right|$ has the property that
\[
\begin{array}{l r}
\mathbb{E}\left(\eta^{2}\right) = \norm{\psi}^{2} & \mathbb{E}\left(\eta^{4}\right) \leq 2\norm{\psi}^{4}
\end{array}
\]
and thus, the average inner product of $\ket{\psi}$ with equatorial stabilizer states is the norm, with variance at most $\norm{\psi}^{4}$~\cite{Bravyi2018}.\par
The number of samples we need depends on the accuracy desired. It can be shown that given an estimate 
\[\bar{\eta}=\frac{1}{L}\sum_{i}\eta_{i}^{2}\]
then $\bar{\eta}$ approximates $\norm{\psi}$ to within multiplicative error $\epsilon$ with probability $\frac{3}{4}$ if $L=4\epsilon^{-2}$~\cite{Bravyi2018}. We can of course increase this probability to $1-\delta$ by taking $\log{\delta^{-1}}$ estimates of $\bar{\eta}$.\par
In Section~\ref{sec:ch_dch_methods}, we introduced an algorithm for computing inner products between stabilizer states $\ket{\phi}$ and equatorial stabilizer states. This method has computational complexity $O(n^{3})$. Thus, given a stabilizer state decomposition $\ket{\tilde{\psi}}$, we can use compute $\norm{\tilde{\psi}}$ in time $O(L\chi n^{3})$, where $L$ is the number of samples of $\eta$.\par
As part of the sampling routine described in Section~\ref{sec:pbc_decomposition}, we want to compute marginal probabilities $P\left(x_{1},x_{2},\dots x_{j}\right)$ for some $j$-bits. These marginals correspond to fixing $j$ qubits, and projecting the rest onto a $2^{n-j}$ dimensional codespace, generated by $j$ Pauli operators~\cite{Bravyi2016}. This codespace can be generated by $j$ Pauli operators, giving
\[\Pi = \prod_{i=1}^{j}\frac{1}{2}\left(I+P_{i}\right)\]
where $P_{i}$ are $n$ qubit Pauli operators. We can thus apply this projector by measuring each of the Pauli generators in turn. Recall that each Pauli measurement takes time $O(n^{2})$, (c.f.~\ref{sec:dch_ch_methods}) and thus computing $\norm{\Pi\tilde{\psi}}^{2}$ also has runtime $O\left(L\chi n^{3}\right)$.\par
To avoid accumulation of errors, each marginal probability needs to be computed with multiplicative error $O(w^{-1})$ when sampling from $w$ output bits. Using the bound on the approximation accuracy above, this implies $L=O(w^{2})$. As there are $w$ marginals to compute, sampling with the norm estimation method thus takes time $O(\chi n^{3}w^{3})$.\par
In the gadgetized picture, we can employ norm estimation by first setting the measurement projector $\Pi$, and then updating it to obtain the corresponding PBC $\Pi_{s}$ by conjugating the projector with the Clifford circuit $\mathtt{V_{y}}$. These Pauli updates can be computed efficiently classically, using similar update rules as for a stabilizer tableau~\cite{Aaronson2004}. Otherwise, for decompositions obtained using the sum-over-Cliffords method, no further preprocessing is required.\par
\large{\itshape{Metropolis Estimation}}\par
\subsubsection*{Implementation and Parallelization}
% Extend the simulators of Chapter 2 w/ wrapper
% Swappable CH/DCH methids
% Building Decompositions and Sampling Outputs is intrinsically trivially parallelizable
% Locally parallised w/ OpenMP
% Distributable w/ MPI
% Requires some synchronisation, especially for sampling
\par
\large{\itshape{Integration with \texttt{Qiskit-Aer}}\par
% Also possible to integrate this runner w/ Qiskit Aer
% Circuits parsed by qiskit, build decomposition and then do measurements w/ MC
% Includes support for Noise sampling w/ naive method
% Offers improvements over builtin statevector method
\par
\subsection{Simulations of Quantum Circuits}
% Results of simulations performed with this method
\subsubsection*{Hidden Shift Circuits}
% Used to verify the Simulator
% Test both RandomCode and SoC Methods
% Validate results through comparison to existing MATLAB code
\subsubsection*{QAOA}
% Simulation of an algorithm w/ many Z rotations
% Significant Advantage over old methods w/ synthesis
% Verifiable w/ MC method
% Solvable in minutes w/ Parallelization
\subsubsection*{Random Circuit Models}
% Introduce cicuit model, supremacy test
% Clear signature of 'quantumness' in XE
% Look at dimensionality effects
% Look at CZ Schedule effects
\section{Discussion}
% Significant Advantages over BG16, and other `general purpise' simulators
% Further optimization needed to compete w/ methods like ollright
\subsection{Simulating NISQ Circuits}
% Good use case
% Circuits typically limited in depth and n/ qubits
% Increasing noise w/ depth => trade off in accuracy
% Potential to probe e.g. families of ansatz states in VQE and other variational methods
\subsection{Simulating Random Circuits}
% Current approach uses naive T expansion
% Circuits have lots of structure that could be used
% E.g clifford recompilation, just lots of Pauli blocks, find `contractive' clifford expansions
% ALternatively, look at local rearrangements of T gates
% Reducing T count and increased resources could lead to good results!
\subsection{Incorporating Noise}
% Noise typically makes classical simulation easier
% Above certain noise thresholds mixed state computation is efficiently classically simulable
% Noise has no clear model in this simulator
% Could imagine sampling noise w/ clifford gates and measurement => Will in general decrease rank but hard to estiamte actual effect on runtime
% Consider 'Mixed State Extension' => Better asymptotic behaviour than robustness
% Unclear how to construct in practice...
